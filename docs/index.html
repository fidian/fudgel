<html>
    <head>
        <title>Fudgel - Lightweight Web Component Library</title>
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/apple-touch-icon.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/favicon-16x16.png"
        />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
        <meta name="msapplication-TileColor" content="#da532c" />
        <meta name="theme-color" content="#ffffff" />
        <style>
            code {
                background-color: #ddd;
                padding: 0.1em 0.3em;
            }

            code-sample + code-sample {
                padding-top: 0.2em;
            }

            li + li {
                padding-top: 0.2em;
            }

            /* Hide body until ACSS-Live processes it */
            body {
                display: none;
            }
        </style>
    </head>
    <body class="D(f) Fxd(c) Ai(c) Fz(1.2em) F(a)">
        <div class="W(100%) Maw(960px)">
            <div class="D(f) Jc(c) Ai(c)">
                <img src="logo.png" alt="Fudgel Logo" class="Maw(200px)" />
                <div class="Pstart(1em)">
                    <div class="Fz(3em)">Fudgel</div>
                    <div class="Fz(1.8em) Pt(0.5em)">
                        A lightweight web component library that eliminates pain
                        and boilerplate.
                    </div>
                    <div class="Fz(1.8em) Pt(0.5em)">Write less. Do more.</div>
                </div>
            </div>
            <p>
                Learning new technologies, tooling, and techniques constantly is
                an annoyance. Staying on the bleeding edge of technology can be
                painful. Why keep learning new things? Can't new things look and
                feel like traditional JavaScript and HTML? Yes, it absolutely
                can. Fudgel lets you write an HTML template and associate it
                with a JavaScript class that acts as its controller. You call
                methods from the HTML to do things in the class. Likewise,
                changes in the class are automatically reflected in the HTML.
                You don't have to manually redraw or worry about the magic; it
                just works.
            </p>
            <p>
                When given a class as a controller, Fudgel will automatically
                parse the HTML template and set up bindings to your controller's
                properties. When they change, the HTML is automatically updated.
                It also handles events, passes data as attributes and
                properties, and fully supports TypeScript. All of this is done
                while allowing you, the developer, to maintain control; add
                additional directives, hook into the component's lifecycle, and
                even handle content projection using slots.
            </p>
            <p>What do you get by using Fudgel?</p>
            <ul>
                <li>One-way data binding (controller to HTML)</li>
                <li>Mustache-like syntax for text and attributes</li>
                <li>
                    Automatic updates when properties change, and only updating
                    affected DOM nodes
                </li>
                <li>
                    Property update detection and two-way attribute bindings
                </li>
                <li>Ability to add code during different lifecycle events</li>
                <li>
                    Event handlers, tying events to your controller's methods
                </li>
                <li>Support for styles within the shadow DOM</li>
                <li>Iterate over objects, arrays, maps, and other iterables</li>
                <li>Conditionally remove elements</li>
                <li>Child element references</li>
                <li>
                    No build system needed; you can just use vanilla JavaScript
                </li>
                <li>Full TypeScript support and also published as a module</li>
                <li>When used with a build system, fully tree-shakeable</li>
                <li>Darn small, coming in at about 3k minified and gzipped</li>
                <li>Parent elements will initialize before children</li>
            </ul>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { component } from 'fudgel';

                    component('my-custom-element', {
                        template: `
                            Hello {{this.name}}, welcome to Fudgel!
                        `
                    }, class MyCustomElement {
                        name = "Developer"

                        onInit() {
                            setTimeout(() =&gt; this.name = 'Super Developer', 5000);
                        }
                    });
                </template>
            </code-sample>
            <p>
                In the above example, a new custom element is defined. Whenever
                you use the new HTML element
                <!-- NOTE: these are not standard hyphens -->
                <code>&lt;my‑custom‑element&gt;</code>, it will automatically
                insert "Hello Developer, welcome to Fudgel!" as text. Because of
                the timeout set up in <code>onInit</code> (a lifecycle method),
                in five seconds the text automatically changes to "Hello Super
                Developer, welcome to Fudgel!"
            </p>
            <p>
                Web components make great additions to your browser-based UI
                because they basically work everywhere. Self-contained chunks of
                functionality that can eliminate lots of work on your side.
                Also, upgrading them or upgrading your existing framework is
                easier because their dependencies are built into the custom
                element. The downside is a bit of extra size from the wiring
                that has to take place, but Fudgel limits that to just the
                necessities.
            </p>
            <p>
                Is this a framework? Perhaps, depending on your definition. This
                provides the structure and removes a lot of hassle when trying
                to wire up custom elements in order to make web components. It
                does this by providing many of the features you could see in
                other frameworks, while keeping the bundle size small. Fudgel
                adds about 3k (minified and compressed) to your assets that need
                to be delivered. This is extraordinaly small when compared to
                some of the more popular frameworks like Angular or React.
            </p>
            <h2>Browser Support</h2>
            <p>
                Over 96% of today's web browser traffic would work with this
                library. This includes Chrome (computer and Android), Edge,
                Safari (computer and iOS), Firefox, and others. There's no
                support for Internet Explorer. See the detailed browser feature
                list and supported browsers at
                <a
                    href="https://caniuse.com/?feats=mdn-html_elements_slot,template,mdn-api_customelementregistry,template-literals,es6,mdn-javascript_builtins_object_defineproperty,customevent,mdn-api_shadowroot,mdn-api_document_createelement,mdn-javascript_builtins_weakmap,mdn-javascript_builtins_object_create,mdn-javascript_builtins_object_getownpropertydescriptor,mdn-javascript_builtins_object_getprototypeof"
                    >CanIUse.com</a
                >.
            </p>
            <h2>Goals and Prior Work</h2>
            <p>
                Fudgel was designed to make a JavaScript and HTML developer feel
                comfortable quickly. It does the heavy lifting by automatic
                bindings and updates while the developer focuses entirely on the
                interactions. The focus is to create self-contained web
                components using <code>window.customElement</code>, suitable for
                inclusion on any project.
            </p>
            <p>
                This project has received the benefit of having others blaze
                trails in this area. There's ideas from many other projects as
                well.
            </p>
            <ul>
                <li>
                    <a href="https://slimjs.com/">Slim.js</a> provided the
                    starting point that a lightweight library can contain lots
                    of functionality, such as the automatic bindings and text
                    parser.
                </li>
                <li>
                    <a href="https://angular.io/">Angular</a> has similar
                    lifestyle hooks and structural directives.
                </li>
                <li>
                    <a href="https://mithril.js.org/">Mithril</a> supplied the
                    idea to cancel an event based on
                    <code>return false</code> in the event handler.
                </li>
                <li>
                    <a href="https://alpinejs.dev/">Alpine.js</a> has event
                    handlers using <code>@</code> prefixes.
                </li>
                <li>
                    <a href="https://vuejs.org/">Vue.js</a> is big into using
                    slots for content projection.
                </li>
            </ul>

            <h2>Getting Started</h2>
            <p>
                Step 1: Install Fudgel or include it into your project. This can
                take several forms, depending on your needs.
            </p>

            <ul>
                <li>
                    IIFE / global, available as <code>window.Fudgel</code>:
                    <code-sample type="html">
                        <!-- prettier-ignore -->
                        <template>
                            <script src="https://unpkg.com/fudgel"></script>
                        </template>
                    </code-sample>
                </li>
                <li>
                    Module in browser either as a standalone tag or perhaps
                    loaded through an import:
                    <code-sample type="html">
                        <!-- prettier-ignore -->
                        <template>
                            <script src="https://unpkg.com/fudgel?module"></script>
                        </template>
                    </code-sample>
                    <code-sample type="html">
                        <!-- prettier-ignore -->
                        <template>
                            <script type="module">
                                import { ... } from 'https://unpkg.com/fudgel?module';
                                // ... do stuff with imports here
                            </script>
                        </template>
                    </code-sample>
                </li>
                <li>
                    Locally as a package or module using your favorite tools:
                    <code-sample type="shell">
                        <!-- prettier-ignore -->
                        <template>
                            npm install fudgel
                        </template>
                    </code-sample>
                    <code-sample type="shell">
                        <!-- prettier-ignore -->
                        <template>
                            yarn add fudgel
                        </template>
                    </code-sample>
                    <code-sample type="shell">
                        <!-- prettier-ignore -->
                        <template>
                            bower install fudgel
                        </template>
                    </code-sample>
                </li>
            </ul>
            <p>
                Step 2: At this point you have access to the
                <code>Fudgel</code> object or the module's exports. It's time to
                write your first controller. Select the chunk of code that best
                fits your needs.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    // Vanilla JavaScript using window.Fudgel
                    window.Fudgel.component('my-custom-component', {
                        template: `Hello {{this.audience}}`
                    }, class {
                        audience = 'world';
                    });
                </template>
            </code-sample>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    // Module
                    import { component } from 'fudgel';

                    component('my-custom-component', {
                        template: `Hello {{this.audience}}`
                    }, class {
                        audience = 'world';
                    });
                </template>
            </code-sample>
            <code-sample type="ts">
                <!-- prettier-ignore -->
                <template>
                    // TypeScript with decorators
                    import { Component } from 'fudgel';

                    @Component('my-custom-component', {
                        template: `Hello {{this.audience}}`
                    })
                    export class MyCustomComponent {
                        audience = 'world';
                    }
                </template>
            </code-sample>
            <p>
                Step 3: You've made a custom element. For more fun, take a look
                at the rest of the things Fudgel can do to save you time.
            </p>
            <h2>Component Creation</h2>
            <p>
                The <code>component()</code> function will create a new element
                and register it with <code>window.customElements</code> as long
                as the element was not yet defined. The newly defined custom
                element will be assigned a constructor of
                <code>FudgelElement</code>, not your class. This is done to
                allow you to utilize any property in your class without fear of
                overwriting something important to <code>HTMLElement</code>.
            </p>
            <p>The function call accepts three parameters:</p>
            <ul>
                <li>
                    The name of the custom element, which must contain a hyphen
                </li>
                <li>
                    An object containing configuration to define for the new
                    element
                </li>
                <li>An optional class to instantiate as the controller</li>
            </ul>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { controller } from 'fudgel';

                    controller('say-hello', {
                        template: `<p>Hello, {{this.audience}}!</p>`
                    }, class {
                        audience = 'world';
                    });
                </template>
            </code-sample>
            <p>
                The custom element name needs to contain a hyphen because it is
                part of the custom element spec. The configuration will supply
                necessary information for the new custom component. Lastly, the
                class to use as the controller is optional. If your component
                simply applies styling or can complete its objective using only
                a template, then passing a class isn't required.
            </p>
            <p>
                The object containing configuration can specify the following
                pieces of information.
            </p>
            <ul>
                <li>
                    <code>style</code> - [optional, string] CSS styles for your
                    custom element. Because we use a shadow DOM, this will
                    insert a new <code>&lt;style&gt;</code> element that will
                    affect your component and its children.
                </li>
                <li>
                    <code>template</code> - [required, string] The HTML template
                    that this element will use for content. When there is no
                    content, it is up to the controller to add the necessary DOM
                    elements and bindings. This template will be processed in
                    the element's scope, even when passing content to child
                    custom elements.
                </li>
            </ul>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    controller('new-element', {
                        style: `new-element { display: block }`,
                        template: `<p>This is my new element</p>`
                    });
                </template>
            </code-sample>
            <p>
                If you use TypeScript, you can also use the
                <code>@Component()</code> decorator, which takes only the first
                two parameters; the element name and the object of static
                values.
            </p>
            <code-sample type="ts">
                <!-- prettier-ignore -->
                <template>
                    import { @Controller } from 'fudgel';

                    @Controller('say-hello', {
                        template: `<p>Hello, {{this.audience}}</p>`
                    })
                    export class SayHelloComponent {
                        audience = 'world';
                    }
                </template>
            </code-sample>
            <h2>Attr and Prop</h2>
            <p>
                There are two other helpers in the project that will link your
                controller to values on the custom element. Attributes are the
                string values added via the HTML. Properties are values set
                through JavaScript on the <code>HTMLElement</code> instance.
            </p>
            <p>
                To illustrate this difference, consider the following HTML. This
                custom element will have the "heading" attribute set to
                <code>"Table of Contents"</code>. Attributes are restricted to
                just strings. A nice feature of attributes is that when the
                controller class's property is updated, the HTMLElement's
                attribute is also automatically updated.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <heading-label
                        id="test"
                        heading="Table of Contents"
                    ></heading-label>
                </template>
            </code-sample>
            <p>
                There are no properties defined through HTML, but let's run a
                bit of JavaScript to get the object and assign a value.
                Properties can hold any type of value, including objects and
                dates.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    const element = document.getElementById("test");
                    element.someProp = [ "one", "two" ];
                </template>
            </code-sample>
            <p>
                In order to bind your custom element to an attribute or property
                and have the controller's property change automatically, there
                are some helper functions you can use.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { attr, component, prop } from 'fudgel';

                    component('prop-and-attr', {
                        template: `
                            <div><b>prop</b>: {{this.myProp}}</div>
                            <div><b>attr</b>: {{this.myAttr}}</div>
                        `
                    }, class {
                        constructor() {
                            attr(this, 'myAttr');
                            prop(this, 'myProp');
                        }
                    });
                </template>
            </code-sample>
            <p>
                In TypeScript, this same result can happen through decorators.
            </p>
            <code-sample type="ts">
                <!-- prettier-ignore -->
                <template>
                    import { Attr, Component, Prop } from 'fudgel';

                    @Component('prop-and-attr', {
                        template: `
                            <div><b>prop</b>: {{this.myProp}}</div>
                            <div><b>attr</b>: {{this.myAttr}}</div>
                        `
                    })
                    class {
                        @Attr() myAttr: string;
                        @Prop() myProp: any;
                    });
                </template>
            </code-sample>
            <p>
                With this set up, you are now able to respond to changes in the
                properties and attributes of the <code>HTMLElement</code> when
                any outside actor changes them, such as with jQuery's
                <code>$element.attr()</code> or Angular's
                <code>[propName]="value"</code> mechanisms. These are just two
                examples and this functionality works with your favorite
                frameworks equally well.
            </p>
            <h2>Styles</h2>
            <p>
                What's the web without CSS? Fudgel supports automatically adding
                a style tag for your new element. These are created within the
                shadow root and are thus scoped to your element and its
                children. Styles are a string containing plain CSS. In the below
                example, all buttons within the element will be styled but none
                outside of the element will have those styles applied.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { component } from 'fudgel';

                    component('styled-click-me-button', {
                        style: `
                            button {
                                border-radius: 4px;
                                border-width: 2x;
                                border-color: blue;
                                border-style: solid;
                            }
                        `,
                        template: `<button>Click me</button>`
                    });
                </template>
            </code-sample>
            <h2>Built-In Directives</h2>
            <p>
                Directives appear as attributes in your HTML within the template
                for the element. Fudgel comes with several directives to handle
                common use cases. Directives are split into structural
                directives, which affect adding and removing DOM elements, and
                general directives, which leaves the DOM structure intact.
            </p>
            <h3>General Directives</h3>
            <p>
                Text nodes and attributes may use a syntax similar to
                <a href="https://mustache.github.io/">Mustache</a>, using double
                braces. The content within will be evaluated as JavaScript and
                the value that is returned will be inserted in place of the
                braces. Below, <code>this</code> refers to the controller
                instance and the content within the braces will be updated
                whenever the referenced variable changes.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <div class="class1 class2 {{this.extraClasses}}">
                        Hello, {{this.user.firstName}}!
                    </div>
                </template>
            </code-sample>
            <p>
                If you need to pass more complicated data and if the custom
                element supports it, you can assign properties directly to the
                element. Again, if the referenced variables change, the property
                will automatically be updated. This is done by prefixing the
                property name with a dot and changing the name to kebab-case
                (hyphenated).
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <!-- Effectively the same as
                        otherElement.currentUser = this.user
                    -->
                    <other-element .current-user="this.user"></other-element>
                </template>
            </code-sample>
            <p>
                Event handlers are bound with a prefixed attribute. If your
                event handling code returns false, the event's default action
                will be canceled and propagation will be stopped. The event is
                available as <code>$event</code> in this code snippet.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <button @click="this.dispatchClick($event); return false">
                        Click me!
                    </button>
                </template>
            </code-sample>
            <p>
                Child elements can be referenced within your controller after
                the lifecycle event <code>onViewInit</code>. This uses the
                <code>#ref</code> attribute, and the value of the attribute is
                the name you want assigned in your controller.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { controller } from 'fudgel';

                    controller('my-custom-element', {
                        template: `
                            <div><span #ref="theSpan"></span></div>
                        `
                    }, class {
                        onViewInit() {
                            // Shows the span in the console
                            console.log(this.theSpan);
                        }
                    });
                </template>
            </code-sample>
            <h3>Structural Directives</h3>
            <p>
                Conditionally display an element with <code>*if</code>. This
                will automatically be updated if using a property on your
                controller.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <p>Showing
                        <span *ngIf="this.username">{{this.username}}</span>
                        <span *ngIf="!this.username">an unknown user</span>
                    </p>
                </template>
            </code-sample>
            <p>
                Repeating a chunk of HTML a number of times is very easy. You
                can use a fixed number or execute code to find the number.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <p>5 stars: <span *repeat="5">*</span></p>
                    <p>Some stars: <span *repeat="this.starCount">*</span></p>
                </template>
            </code-sample>
            <p>
                Iterating across an object, array, set, map, or any other
                iterable is also possible, plus this also updates when the
                property on your controller is updated. The key and value are
                assigned to <code>$scope.key</code> and
                <code>$scope.value</code>.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <ul>
                        <li *for="this.saleItemArray">{{$scope.value.itemPrice}}</li>
                    </ul>
                </template>
            </code-sample>
            <p>
                You can rename <code>$scope.key</code> and
                <code>$scope.value</code> to suit your needs. Also, nested
                scopes inherit from each other, exactly how you think they
                should.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <div *for="username, user of this.userObjectKeyedByUsername">
                        <p>{{$scope.username}}:</p>
                        <ul>
                            <li *for="value of $scope.user.favoriteThings">
                                {{$scope.user.firstName}} likes {{$scope.value}}
                            </li>
                        </ul>
                    </div>
                </template>
            </code-sample>
            <h2>Lifecycle Methods and Hooks</h2>
            <p>
                If your controller has any of these methods, they will be called
                during specific moments during the lifecycle of your controller.
            </p>
            <p>
                <code>onInit()</code> is called after the custom element is
                connected to a DOM. It's a good place to set up your initial
                properties. Child elements are not yet attached to the DOM,
                templates are not parsed, and most other things are not yet set
                up.
            </p>
            <p>
                <code>onViewInit()</code>, if you have one, will be executed at
                the very end after the custom element is connected to the DOM.
                At this point, all children are in the DOM,
                <code>#ref</code> directives are set up, and your element is
                basically live.
            </p>
            <p>
                <code>onChange(propertyName, oldValue, newValue)</code> will be
                triggered whenever a monitored property is updated. Monitored
                properties are the ones that are referenced in a template.
                Differences are detected by using <code>===</code> (strict
                equals), so changes to immutable objects trigger change
                detection more easily.
            </p>
            <p>
                <code>onDestroy()</code> is when the controller is being
                detached from the custom element and the custom element is being
                disconnected from the DOM.
            </p>
            <h2>Adding Custom Directives</h2>
            <p>
                You are welcome to add your own directives. There are three
                categories of directives when you add one. First, structural
                directives start with <code>*</code>. Next, you can use a
                prefixed directive that matches all attributes that start with a
                specific character, such as <code>.</code> for property changes.
                Finally, you can match an exact directive, as in
                <code>#ref</code>.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { addDirective } from 'fudgel';

                    // Specific attribute
                    addDirective('#name',
                        (controller, node, attrValue, attrName) =&gt; { ... });

                    // An attribute prefix
                    addDirective('?',
                        (controller, node, attrValue, attrName) =&gt; { ... });

                    // A structural directive, which starts with *
                    addDirective('*extra',
                        (controller, anchor, node, attrValue) =&gt; { ... });
                </template>
            </code-sample>
            <p>
                Your custom directive function must perform whatever
                manipulation in the DOM that is necessary. For structural
                directives, a comment is added just before the element that you
                can use as an anchor point for adding or removing elements.
            </p>
            <h2>Content Projection using Slots</h2>
            <p>
                Imagine you have a utility function to create a styled button.
                You'd like the ability to specify the HTML that is displayed on
                the button, but passing that in via an attribute or property is
                problematic, especially when you want to have an image on the
                button. You can use slotted content to achieve the same result.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { component } from 'fudgel';

                    component('custom-button', {
                        style: `
                            button {
                                border-radius: 4px;
                                border-width: 2x;
                                border-color: blue;
                                border-style: solid;
                            }
                        `,
                        template: `<button><slot></slot></button>`
                    });

                    component('save-button', {
                        template: `<custom-button><img src="save.png"> Save</custom-button>`
                    });
                </template>
            </code-sample>
            <p>
                You can also project multiple pieces of content using named
                slots. Read more about
                <a
                    href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/slot"
                    ><code>slot</code> elements</a
                >
                and
                <a
                    href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/slot"
                    ><code>slot</code> attributes</a
                >.
            </p>
            <h2>Utility Functions</h2>
            <p>
                Dispatching events from your controller can be tricky with the
                shadow DOM. DOM. Also, for minification, you will probably want
                to leverage shared code to send events.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { component, emit } from 'fudgel';

                    component('button-sample', {
                        template: `
                            <button @click="return this.clicked()">Click me</button>
                        `
                    }, class {
                        clicked() {
                            emit(this, 'button-sample-event', {
                                extraData: 'can go in here',
                                youCanUse: 'whatever you like',
                                when: new Date()
                            });
                            // Automatically cancel the click event
                            // and prevent propagation.
                            return false;
                        }
                    });
                </template>
            </code-sample>
            <p>
                When you update internal data within an object, the change
                detection will not pick it up. You can flag specific properties
                as needing to be redrawn, as this example shows.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { component, emit } from 'fudgel';

                    component('user-sample', {
                        template: `
                            <p>Name: {{this.user.name}}</p>
                            <button @click="return this.clicked()">Update</button>
                        `
                    }, class {
                        onInit() {
                            this.user = {
                                name: "Test User"
                            };
                        }

                        clicked() {
                            this.user.name = "Updated";
                            update(this, "user");
                        }
                    });
                </template>
            </code-sample>
            <p>
                <code>update()</code> takes two optional parameters and behaves differently depending on what you pass into the function.
            </p>
            <ul>
                <li><code>update(controller, 'property')</code> - Updates all bindings for a single property on a controller. This is the fastest call to make.</li>
                <li><code>update(controller)</code> - Reruns all bindings that are attached to the controller. This affects all properties and every dynamic piece of HTML that is controlled by your controller.</li>
                <li><code>update()</code> - The slowest of all ways to trigger an update, this form will update all bindings for all Fudgel components everywhere.</li>
            </ul>
            <h2>Best Practices</h2>
            <p>
                Do not register your custom element in your exported module.
                That does not allow other developers to resolve conflicts. If
                your custom element is named "heading-bar" and another library
                uses the same named element, the conflict is unable to be worked
                around. Instead, export a function that allows another developer
                to prefix your element and any other custom elements you
                require.
            </p>
            <p>
                In general, you want your element to accept data into the
                controller using attributes (strings) and properties (any data).
                Attributes have universal support, where as most support
                properties. When you need to send data out of your controller,
                send an event.
            </p>
        </div>
    </body>
    <!-- Turn the class names into styles automatically. Eliminate CSS from your project. -->
    <script src="acss-live.min.js"></script>
    <!-- Syntax highlighting for code-sample custom element. -->
    <script src="highlight.min.js"></script>
    <!-- Minified Fudgel -->
    <script src="index.umd.min.js"></script>
    <!-- Custom elements -->
    <script src="code-sample.js"></script>
</html>
