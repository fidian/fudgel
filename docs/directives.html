<html>
    <head>
        <title>Fudgel - Lightweight Web Component Library</title>
        <link rel="stylesheet" href="fonts/fonts.css" />
        <link rel="stylesheet" href="./style.css" />
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/apple-touch-icon.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/favicon-16x16.png"
        />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
        <meta name="msapplication-TileColor" content="#da532c" />
        <meta name="theme-color" content="#ffffff" />
    </head>
    <body>
        <page-wrapper>
            <h1>Built-In Directives</h1>
            <p>
                Directives appear as attributes in your HTML within the template
                for the element. Fudgel comes with several directives to handle
                common use cases. Directives are split into structural
                directives, which affect adding and removing DOM elements, and
                general directives, which leaves the DOM structure intact.
            </p>
            <h2>General Directives</h2>
            <p>
                Text nodes and attributes may use a syntax similar to
                <a href="https://mustache.github.io/">Mustache</a>, using double
                braces. The content within will be evaluated as JavaScript and
                the value that is returned will be inserted in place of the
                braces. Below, <code>this</code> refers to the controller
                instance and the content within the braces will be updated
                whenever the referenced variable changes.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <div class="class1 class2 {{extraClasses}}">
                        Hello, {{user.firstName}}!
                    </div>
                </template>
            </code-sample>
            <p>
                If you need to pass more complicated data and if the custom
                element supports it, you can assign properties directly to the
                element. Again, if the referenced variables change, the property
                will automatically be updated. This is done by prefixing the
                property name with a dot and changing the name to kebab-case
                (hyphenated).
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <!-- Effectively the same as
                        otherElement.currentUser = this.user
                    -->
                    <other-element .current-user="user"></other-element>
                </template>
            </code-sample>
            <p>
                Event handlers are bound with a prefixed attribute. The event is
                available as <code>$event</code>.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <button @click="dispatchClick($event)">
                        Click me!
                    </button>
                </template>
            </code-sample>
            <p>
                Event handlers can also have modifiers, indicating what should
                be done with the event. These are separated by a period and
                appear after the event name, always in kebab-case.
            </p>
            <ul>
                <li>
                    <code>capture</code> - Dispatch the event to the registered
                    listener before dispatching to any event targets beneath it
                    in the DOM tree.
                </li>
                <li><code>document</code> - Bind the event to the document.</li>
                <li><code>once</code> - Invoke the listener at most once.</li>
                <li>
                    <code>outside</code> - Bind the event to the document and
                    only fire when there's a click outside of the targeted
                    element.
                </li>
                <li>
                    <code>passive</code> - Signifies that this event is passive
                    and the developer will not call <code>preventDefault</code>
                    on the event, allowing the engine to tweak how the event is
                    processed.
                </li>
                <li>
                    <code>prevent</code> - Calls <code>preventDefault</code> on
                    the event.
                </li>
                <li>
                    <code>self</code> - Only fires the event when the click is
                    on the target element.
                </li>
                <li>
                    <code>stop</code> - Calls <code>stopPropagation</code> on
                    the event.
                </li>
                <li><code>window</code> - Bind the event to the window.</li>
            </ul>
            <code-sample
                type="js"
                live="true"
                html="<test-events></test-events>"
            >
                <!-- prettier-ignore -->
                <template>
                    import { component } from './fudgel.min.js';

                    component('test-events', {
                        template: `
                            <div
                                @click.stop.prevent.outside="click('outside')"
                                @click.stop.prevent="click('inside')"
                                style="border: 1px solid black; padding: 10px; display: inline-block;"
                                >
                                Click inside or outside this box
                            </div>
                            <div>{{clickMessage}}</div>
                        `
                    }, class {
                        clickMessage = 'Ready for your next click';
                        timeout = null;
                        click(message) {
                            if (this.timeout) {
                                clearTimeout(this.timeout);
                            }
                            this.clickMessage = `You clicked ${message} the box!`;
                            this.timeout = setTimeout(() =&gt; {
                                this.clickMessage = 'Ready for your next click';
                                this.timeout = null;
                            }, 2000);
                        }
                    });
                </template>
            </code-sample>
            <p>
                You can also fire events only when certain key combinations are
                pressed.
            </p>
            <ul>
                <li><code>alt</code> - The alt key must be pressed.</li>
                <li><code>ctrl</code> - The control key must be pressed.</li>
                <li>
                    <code>meta</code> - The meta key must be pressed, which is
                    the same as the Command key on Mac or Super key on Windows.
                </li>
                <li><code>shift</code> - The shift key must be pressed.</li>
                <li>
                    <code>exact</code> - The exact key combination must be
                    pressed. This means using
                    <code>keypress.ctrl.exact</code> only fires when a
                    control-key combination is pressed but will not fire if the
                    shift key is also pressed.
                </li>
            </ul>
            <code-sample
                type="js"
                live="true"
                html="<test-events></test-events>"
            >
                <!-- prettier-ignore -->
                <template>
                    import { component } from './fudgel.min.js';

                    component('test-events', {
                        template: `
                            <button
                                @click.stop.prevent="changeClicks()"
                                @click.ctrl="changeControlClicks()"
                                @click.shift.exact="changeShiftClicksExact()"
                                >
                                Click me!
                            </button>
                            <div>Number of clicks: {{clicks}}</div>
                            <div>Number of control-clicks: {{controlClicks}}</div>
                            <div>Number of shift-clicks with exact: {{shiftClicksExact}}</div>
                        `
                    }, class {
                        clicks = 0;
                        controlClicks = 0;
                        shiftClicksExact = 0;
                        changeClicks() {
                            this.clicks += 1;
                        }
                        changeControlClicks() {
                            this.controlClicks += 1;
                        }
                        changeShiftClicksExact() {
                            this.shiftClicksExact += 1;
                        }
                    });
                </template>
            </code-sample>
            <p>
                Finally, any other event modifier will be treated as a key
                value. This means using <code>keypress.a</code> will only fire
                when the "a" key is pressed. Key values are listed on
                <a
                    href="https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values"
                    >MDN's Keyboard Event Key Values page</a
                >. Make sure to use all lowercase and kebab-case names, such as
                <code>keypress.arrow-left</code>.
            </p>
            <p>
                Some keys are difficult to represent as HTML attributes, so you
                can use their ASCII values or code point values, such as
                <code>keypress.code-32</code> for space (hex 0x20, ASCII code
                point 32) and <code>keypress.code-252</code> for ü.
            </p>
            <code-sample
                type="js"
                live="true"
                html="<test-events></test-events>"
            >
                <!-- prettier-ignore -->
                <template>
                    import { component } from './fudgel.min.js';

                    component('test-events', {
                        template: `
                            <div>
                                <input type="text"
                                       @keypress.code-32="changeSpaceCount()"
                                       @keydown.enter="input2.focus()"
                                       @keydown.tab.stop.prevent="message($event)"
                                       #ref="input1"
                                       />
                                ({{spaceCount}} spaces pressed)
                            </div>
                            <input type="text"
                                   @keypress.code-32="changeSpaceCount()"
                                   @keydown.enter="input1.focus()"
                                   @keydown.tab.stop.prevent="message($event)"
                                   #ref="input2"
                                   />
                            <div>Press enter to switch between fields</div>
                            <div>Press tab for silly messages</div>
                        `
                    }, class {
                        spaceCount = 0;
                        changeSpaceCount() {
                            this.spaceCount += 1;
                        }
                        message(event) {
                            this.input1.value = 'You pressed tab!';
                            this.input2.value = 'Congratulations!';
                            alert('Here is a silly message!');
                        }
                    });
                </template>
            </code-sample>
            <h2>Structural Directives</h2>
            <p>
                Conditionally display an element with <code>*if</code>. This
                will automatically be updated if using a property on your
                controller.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <p>Showing
                        <span *if="username">{{username}}</span>
                        <span *if="!username">an unknown user</span>
                    </p>
                </template>
            </code-sample>
            <p>
                Repeating a chunk of HTML a number of times is very easy. You
                can use a fixed number or execute code to find the number.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <p>5 stars: <span *repeat="5">*</span></p>
                    <p>Some stars: <span *repeat="starCount">*</span></p>
                </template>
            </code-sample>
            <p>
                Iterating across an object, array, set, map, or any other
                iterable is also possible, plus this also updates when the
                property on your controller is updated. The key and value are
                assigned to <code>key</code> and <code>value</code>.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <ul>
                        <li *for="saleItemArray">{{value.itemPrice}}</li>
                    </ul>
                </template>
            </code-sample>
            <p>
                You can rename <code>key</code> and <code>value</code> to suit
                your needs. Also, nested scopes inherit from each other, exactly
                how you think they should.
            </p>
            <code-sample type="html">
                <!-- prettier-ignore -->
                <template>
                    <div *for="username, user of userObjectKeyedByUsername">
                        <p>{{username}}:</p>
                        <ul>
                            <li *for="value of user.favoriteThings">
                                {{user.firstName}} likes {{value}}
                            </li>
                        </ul>
                    </div>
                </template>
            </code-sample>
            <h2>Adding Custom Directives</h2>
            <p>
                You are welcome to add your own directives. There are three
                categories of directives when you add one. First, structural
                directives start with <code>*</code>. Next, you can use a
                prefixed directive that matches all attributes that start with a
                specific character, such as <code>.</code> for property changes.
                Finally, you can match an exact directive, as in
                <code>#ref</code>.
            </p>
            <code-sample type="js">
                <!-- prettier-ignore -->
                <template>
                    import { addDirective } from 'fudgel';

                    // Specific attribute
                    addDirective('#name',
                        (controller, node, attrValue, attrName) =&gt; { ... });

                    // An attribute prefix
                    addDirective('?',
                        (controller, node, attrValue, attrName) =&gt; { ... });

                    // A structural directive, which must start with *
                    addDirective('*extra',
                        (controller, anchor, node, attrValue) =&gt; { ... });
                </template>
            </code-sample>
            <p>
                Your custom directive function must perform whatever
                manipulation in the DOM that is necessary. For structural
                directives, a comment is added just before the element that you
                can use as an anchor point for adding or removing elements.
            </p>
        </page-wrapper>
    </body>
    <script src="js.js" type="module"></script>
</html>
