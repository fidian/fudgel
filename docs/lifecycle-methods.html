<html>
    <head>
        <title>Fudgel - Lightweight Web Component Library</title>
        <link rel="stylesheet" href="fonts/fonts.css" />
        <link rel="stylesheet" href="./style.css" />
        <link
            rel="apple-touch-icon"
            sizes="180x180"
            href="/apple-touch-icon.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="32x32"
            href="/favicon-32x32.png"
        />
        <link
            rel="icon"
            type="image/png"
            sizes="16x16"
            href="/favicon-16x16.png"
        />
        <link rel="manifest" href="/site.webmanifest" />
        <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5" />
        <meta name="msapplication-TileColor" content="#da532c" />
        <meta name="theme-color" content="#ffffff" />
    </head>
    <body>
        <page-wrapper>
            <h1>Lifecycle Methods and Hooks</h1>
            <p>
                If your controller has any of these methods, they will be called
                during specific moments during the lifecycle of your controller.
            </p>
            <p>
                <code>onInit()</code> is called after the custom element is
                connected to a DOM. It's a good place to set up your initial
                properties. Child elements are not yet attached to the DOM,
                templates are not parsed, and most other things are not yet set
                up.
            </p>
            <p>
                <code>onParse()</code> is fired when all child nodes are parsed
                for light DOM elements and is asynchronously fired just after
                <code>onInit()</code> for shadow DOM elements. If you are doing
                your own light DOM
                <a href="content-projection.html">content projection</a>, this
                would be an important method to use. With lengthy HTML, there
                might be multiple chunks of child nodes added as children to the
                custom element. This method is called after all of them are
                added, using a technique of watching for the document's content
                to be loaded and using a mutation observer to see if any parents
                have next siblings. A parent's <code>onParse()</code> will be
                called before a child's.
            </p>
            <p>
                <code>onViewInit()</code> will be executed asynchronously at the
                very end after the custom element is connected to the DOM and
                the template has also been attached and processed. It will
                always be executed asynchronously. At this point, all children
                are in the DOM, <code>#ref</code> directives are set up, and
                your element is basically live. A parent's
                <code>onViewInit()</code> will be called before a child's. This method is also called before structural directives are applied.
            </p>
            <p>
                <code>onChange(propertyName, oldValue, newValue)</code> will be
                triggered whenever a monitored property is updated. Monitored
                properties are any attribute or property listed in the config.
                Differences are detected by using <code>Object.is()</code>, so
                changes to immutable objects trigger change detection more
                easily.
            </p>
            <p>
                Calling <code>update()</code> (see
                <a href="utilities.html">Utilities</a>) will also call
                <code>onChange()</code> for all attributes and properties that
                are copied into the controller.
            </p>
            <p>
                <code>onDestroy()</code> is when the controller is being
                detached from the custom element and the custom element is being
                disconnected from the DOM.
            </p>
        </page-wrapper>
    </body>
    <script src="js.js" type="module"></script>
</html>
